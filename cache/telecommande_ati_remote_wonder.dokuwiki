{{tag>matériel télécommande VÉTUSTE}}
----


====== Télécommande ATI SAPPHIRE REMOTE WONDER Version 1 ======

Le module pour utiliser cette télécommande est déjà présent dans le noyaux mais nécessite quelques modifications, mais le plus simple est l'utilisation de [[:lirc]].
Cette méthode fonctionne aussi pour la ATI remote wonder (ID: B4SUR84A)


==== Configuration et modification du pilote ====

<code>gedit  linux-source-2.6.35/drivers/input/misc/ati_remote.c</code>

voici la partie intéressante du code dans le ficher ati_remote.c
les keycodes sont placés dans l'avant dernière colonne

<file>/* Directional control pad axes */
 {KIND_ACCEL,   0x35, 0x70, EV_REL, REL_X, -1},     /* left */
{KIND_ACCEL,   0x36, 0x71, EV_REL, REL_X, 1},    /* right */
{KIND_ACCEL,   0x37, 0x72, EV_REL, REL_Y, -1},     /* up */
{KIND_ACCEL,   0x38, 0x73, EV_REL, REL_Y, 1},    /* down */
/* Directional control pad diagonals */
 {KIND_LU,      0x39, 0x74, EV_REL, 0, 0},        /* left up */
{KIND_RU,      0x3a, 0x75, EV_REL, 0, 0},        /* right up */
{KIND_LD,      0x3c, 0x77, EV_REL, 0, 0},        /* left down */
 {KIND_RD,      0x3b, 0x76, EV_REL, 0, 0},        /* right down */

/* "Mouse button" buttons */
{KIND_LITERAL, 0x3d, 0x78, EV_KEY, BTN_LEFT, 1}, /* left btn down */
{KIND_LITERAL, 0x3e, 0x79, EV_KEY, BTN_LEFT, 0}, /* left btn up */
{KIND_LITERAL, 0x41, 0x7c, EV_KEY, BTN_RIGHT, 1},/* right btn down */
{KIND_LITERAL, 0x42, 0x7d, EV_KEY, BTN_RIGHT, 0},/* right btn up */

/* Artificial "doubleclick" events are generated by the hardware.
* They are mapped to the "side" and "extra" mouse buttons here. */
{KIND_FILTERED, 0x3f, 0x7a, EV_KEY, BTN_SIDE, 1}, /* left dblclick */
{KIND_FILTERED, 0x43, 0x7e, EV_KEY, BTN_EXTRA, 1},/* right dblclick */

/* keyboard. */
    {KIND_FILTERED, 0xd2, 0x0d, EV_KEY, KEY_KP1, 1},
    {KIND_FILTERED, 0xd3, 0x0e, EV_KEY, KEY_KP2, 1},
    {KIND_FILTERED, 0xd4, 0x0f, EV_KEY, KEY_KP3, 1},
    {KIND_FILTERED, 0xd5, 0x10, EV_KEY, KEY_KP4, 1},
    {KIND_FILTERED, 0xd6, 0x11, EV_KEY, KEY_KP5, 1},
    {KIND_FILTERED, 0xd7, 0x12, EV_KEY, KEY_KP6, 1},
    {KIND_FILTERED, 0xd8, 0x13, EV_KEY, KEY_KP7, 1},
    {KIND_FILTERED, 0xd9, 0x14, EV_KEY, KEY_KP8, 1},
    {KIND_FILTERED, 0xda, 0x15, EV_KEY, KEY_KP9, 1},
    {KIND_FILTERED, 0xdc, 0x17, EV_KEY, KEY_KP0, 1},
    {KIND_FILTERED, 0xc5, 0x00, EV_KEY, KEY_Q, 1},
    {KIND_FILTERED, 0xc6, 0x01, EV_KEY, KEY_B, 1},
    {KIND_FILTERED, 0xde, 0x19, EV_KEY, KEY_C, 1},
    {KIND_FILTERED, 0xe0, 0x1b, EV_KEY, KEY_D, 1},
    {KIND_FILTERED, 0xe6, 0x21, EV_KEY, KEY_E, 1},
    {KIND_FILTERED, 0xe8, 0x23, EV_KEY, KEY_F, 1},

    /* "special" keys */
    {KIND_FILTERED, 0xdd, 0x18, EV_KEY, KEY_KPENTER, 1},    /* "check" */
    {KIND_FILTERED, 0xdb, 0x16, EV_KEY, KEY_MENU, 1},       /* "menu" */
    {KIND_FILTERED, 0xc7, 0x02, EV_KEY, KEY_POWER, 1},      /* Power */
    {KIND_FILTERED, 0xc8, 0x03, EV_KEY, KEY_TV, 1},         /* TV */
    {KIND_FILTERED, 0xc9, 0x04, EV_KEY, KEY_DVD, 1},        /* DVD */
    {KIND_FILTERED, 0xca, 0x05, EV_KEY, KEY_WWW, 1},        /* WEB */
    {KIND_FILTERED, 0xcb, 0x06, EV_KEY, KEY_BOOKMARKS, 1},  /* "book" */
    {KIND_FILTERED, 0xcc, 0x07, EV_KEY, KEY_EDIT, 1},       /* "hand" */
    {KIND_FILTERED, 0xe1, 0x1c, EV_KEY, KEY_COFFEE, 1},     /* "timer" */
    {KIND_FILTERED, 0xe5, 0x20, EV_KEY, KEY_FRONT, 1},      /* "max" */
    {KIND_FILTERED, 0xe2, 0x1d, EV_KEY, KEY_LEFT, 1},       /* left */
    {KIND_FILTERED, 0xe4, 0x1f, EV_KEY, KEY_RIGHT, 1},      /* right */
    {KIND_FILTERED, 0xe7, 0x22, EV_KEY, KEY_DOWN, 1},       /* down */
    {KIND_FILTERED, 0xdf, 0x1a, EV_KEY, KEY_UP, 1},         /* up */
    {KIND_FILTERED, 0xe3, 0x1e, EV_KEY, KEY_OK, 1},         /* "OK" */
    {KIND_FILTERED, 0xce, 0x09, EV_KEY, KEY_VOLUMEDOWN, 1}, /* VOL + */
    {KIND_FILTERED, 0xcd, 0x08, EV_KEY, KEY_VOLUMEUP, 1},   /* VOL - */
    {KIND_FILTERED, 0xcf, 0x0a, EV_KEY, KEY_MUTE, 1},       /* MUTE  */
    {KIND_FILTERED, 0xd0, 0x0b, EV_KEY, KEY_CHANNELUP, 1},  /* CH + */
    {KIND_FILTERED, 0xd1, 0x0c, EV_KEY, KEY_CHANNELDOWN, 1},/* CH - */
    {KIND_FILTERED, 0xec, 0x27, EV_KEY, KEY_RECORD, 1},     /* ( o) red */
    {KIND_FILTERED, 0xea, 0x25, EV_KEY, KEY_PLAY, 1},       /* ( >) */
    {KIND_FILTERED, 0xe9, 0x24, EV_KEY, KEY_REWIND, 1},     /* (<<) */
    {KIND_FILTERED, 0xeb, 0x26, EV_KEY, KEY_FORWARD, 1},    /* (>>) */
    {KIND_FILTERED, 0xed, 0x28, EV_KEY, KEY_STOP, 1},       /* ([]) */
    {KIND_FILTERED, 0xee, 0x29, EV_KEY, KEY_PAUSE, 1},      /* ('') */
    {KIND_FILTERED, 0xf0, 0x2b, EV_KEY, KEY_PREVIOUS, 1},   /* (<-) */
    {KIND_FILTERED, 0xef, 0x2a, EV_KEY, KEY_NEXT, 1},       /* (>+) */
    {KIND_FILTERED, 0xf2, 0x2D, EV_KEY, KEY_INFO, 1},       /* PLAYING */
    {KIND_FILTERED, 0xf3, 0x2E, EV_KEY, KEY_HOME, 1},       /* TOP */
    {KIND_FILTERED, 0xf4, 0x2F, EV_KEY, KEY_END, 1},        /* END */
    {KIND_FILTERED, 0xf5, 0x30, EV_KEY, KEY_SELECT, 1},     /* SELECT */

    {KIND_END, 0x00, 0x00, EV_MAX + 1, 0, 0}</file>

Pour ma part j'ai changé les touches 0 à 9 par les touches du pavé numérique
et la touche A par la touche Q
ex KEY_1 par KEY_KP1

pour obtenir les codes attribués à chaque touche

<code>gedit /usr/src/linux-headers-`uname -r`/include/linux/input.h</code>

mais pour aller plus loin et configurer les touches TV; DVD; stop ; enregistrement etc ... j'utilise xev et Préférences/raccourcis claviers.

Or les keycodes du input.h du noyau et ceux indiqués par xev, ne sont pas forcément les mêmes:

pour le noyau 2.6.35-22 :

  * pour la touche 1 du clavier numérique le input.h donne 79 comme keycode et xev donne 87!
  * de même pour la touche "windows" ou "super_L" le input.h donne 125(KEY_LEFTMETA) et xev donne 133

Il y a donc un décalage dans le cas de ce noyau de 8 codes!

<note help>Petite astuce si la touche Windows ne fonctionne pas:
<code> gconftool-2 --set /apps/metacity/global_keybindings/panel_main_menu --type string "Super_L" </code> rétablis la touche windows.</note>

Donc pour attribuer les bons codes aux touches:

  *  __Votre clavier multimédia a des touches multimédia non configurées__ 


 Exemple:
 
 xev renvoie pour la touche FN + F5:
   
 <code>" state 0x2010, keycode 156 (keysym 0x1008ff41, XF86Launch1), same_screen YES "</code>
   
donc le keycode associé dans le fichier input.h est 156-8=148 donc KEY_PROG1 pour le noyau 2.6.35-22
   
Il suffit alors de remplacer dans ati_remote.c :

<code>{KIND_FILTERED, 0xc9, 0x04, EV_KEY, KEY_DVD, 1},        /* DVD */</code>

par 
   
<code>{KIND_FILTERED, 0xc9, 0x04, EV_KEY, KEY_PROG1, 1},        /* DVD */</code>
   
Enfin , nous voulons utiliser notre lecteur multimédia préféré:( vlc dans mon cas) pour la touche DVD de la télécommande
   
Il suffit d'aller dans Préférences/raccourcis claviers et ajouter le lancement de vlc avec comme touche de raccourcis le keysym XF86Launch1
et le tour est joué !
 
  * __Votre clavier multimédia est parfaitement configuré:__

   
Il faut donc chercher donc connaitre le keycode de la touche et keysim associé.

La commande : <code>$ xmodmap -pke </code>
vous donne la relation keycode-keysim; sinon xev fait normalement bien le travail
On cherche alors la correspondance du keycode dans le fichier input.h (en retirant 8 dans le cas du noyau 2.6.35-22)
   
Voir l'exemple prédent pour la fin de la modification du ficher ati_remote.c
   

une fois le fichier modifié, il n'y a plus qu'à compiler le pilote


<code>gedit  linux-source-2.6.17/drivers/usb/input/Makefile</code>

version intrepid et suivante:

<code>gedit  linux-source-2.6.35/drivers/input/misc/Makefile</code>
voici le Makefile :
<code>
VERSION = 2
PATCHLEVEL = 6
SUBLEVEL = 35
EXTRAVERSION = .13-ubuntu1
NAME=Crazed Snow-Weasel

ifneq ($(KERNELRELEASE),)
#
# Make rules for use from within 2.6 kbuild system
#
obj-m    += ati_remote.o

else  # We were called from command line

KDIR	:= /lib/modules/$(shell uname -r)/build
PWD	:= $(shell pwd)
all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules
install: all
	$(MAKE) -C $(KDIR) M=$(PWD) modules_install
clean:
	rm -f *.mod.c *.ko *.o *~ core *.i
endif</code>


<code>cd linux-source-2.6.17/drivers/usb/input/
make</code>

version intrepid et suivantes:

<code>cd linux-source-2.6.35/drivers/input/misc
make</code>

le pilote compilé est le fichier ati_remote.ko

Pour le tester dans un premier temps:
- enlever le pilote actuel déjà chargé

<code>sudo rmmod ati_remote</code>

la télécommande ne répond plus à présent.



==== Installation du nouveau module ====

<code>sudo insmod ati_remote.ko</code>

la commande se fait toujours dans le répertoire ou se situe le fichier ati_remote.ko
normalement la télécommande réagit avec les nouvelles touches assignées

Maintenant pour l'installer définitivement

<code>sudo cp ati_remote.ko /lib/modules/`uname -r`/kernel/drivers/usb/input/ati_remote.ko</code>

version intrepid et suivantes:

<code>sudo cp ati_remote.ko /lib/modules/`uname -r`/kernel/drivers/input/misc/ati_remote.ko</code>


Cette méthode n'est pas très élégante puisqu'elle écrase le module actuel
Mais elle évite tout conflit avec l'ancien pilote puisqu'il n'existe plus
de plus le pilote est chargé directement au démarrage
Si écraser le fichier vous fait hérisser les poils, il est possible de faire un backup du fichier avant de l'écraser.


==== Changer le canal de communication ====
Si votre voisin a eu la bonne idée d'acheter la même télécommande que vous, il se peux qu'il arrive à prendre le contrôle de votre ordinateur (et vous le contrôle du sien). Pour remédier à ce problème assez embêtant, il faut changer le canal de communication de la télécommande pour se distinguer de celle du voisin.

=== Configuration de la télécommande ===
Pour cela, on appuie quelques secondes sur le bouton "main" de la télécommande jusqu'à ce que la LED de contrôle se mette à clignoter. Elle clignote autant de fois que le numéro du canal sur lequel est configuré la télécommande. Une fois que la LED cesse de clignoter, on rentre un nouveau canal (différent du voisin bien sûr) à l'aide des touches numériques (les canaux vont de 1 à 16, ne pas oublier de mettre le 0 si on choisi un canal de 1 à 9, ex : 07). On confirme le numéro en ré-appuyant sur le bouton "main". La LED clignote le nombre de fois correspondant au canal sélectionné pour confirmer.

=== Configuration du module ===
Il faut ensuite procéder à la configuration du module. A partir de là, 2 choix s'offre a nous : soit on masque le canal du voisin, soit on autorise que le nôtre, tout dépend si on connaît le canal du voisin :p

== Masquer un seul canal ==
Le calcul du masque est assez simple : 2^canal_voisin
Retenez ensuite la valeur, on va en avoir besoin pour la configuration

== Autoriser un seul canal ==
Là aussi le calcul n'est pas beaucoup plus compliqué : 65535-(2^canal)

== Tests et enregistrement du masque ==
Une fois le masque trouvé, on va le tester avant de l'enregistrer. Pour cela, commencez par décharger le module à l'aide de la commande
<code>sudo rmmod ati_remote</code>
Puis rechargez le en passant en paramètre le masque calculé via la commande
<code>sudo modprobe ati_remote channel_mask=masque</code>
Remplacez masque par le masque calculé juste au dessus.

Il vous reste à tester maintenant si l'ordinateur répond toujours aux commandes de la télécommande :)

Si tout est ok, il ne reste plus qu'à enregistrer le masque pour que le module soit chargé avec celui-ci au démarrage. Pour cela, éditer le fichier /etc/modprobe.d/options

Sur ubuntu :
<code>gksudo gedit /etc/modprobe.d/options</code>
Sur kubuntu :
<code>kdesu kate /etc/modprobe.d/options</code>

A la fin du fichier, rajouter ceci
<code>
# Set channel for ATI Remote Wonder
options ati_remote channel_mask=masque
</code>
En remplaçant toujours masque par le masque calculé

== Et si ça ne marche pas ? ==
Il est possible d'activer un mode debug pour voir les signaux capturés et ceux masqués à l'aide de la commande
<code>sudo modprobe channel_mask=masque debug=1</code>

Tout sera alors loggué dans le fichier /var/log/syslog, pour l'afficher en temps réel, exécutez
<code>tail -f /var/log/syslog</code>






===== Utiliser sa télécommande avec le programme LIRC =====

Lirc est un programme permettant de contrôler à l'aide d'une télécommande votre ordinateur.

L'avantage de ce programme est qu'il peut s'adapter à presque toute vos envies. Son principal défaut est une installation complexe, voici la méthode la plus simple pour installer et configurer Lirc sur votre ordinateur.

Vous trouverez sur le wiki d'autres pages traitant de la configuration de lirc et notamment une page présentant les fichiers lircrc permettant de personnaliser l'utilisation de votre télécommande.

Remarque d'un lecteur : Vous trouverez [[http://blog.roozeec.fr/2007/04/18/telecommande-ati-remote-wonder-sous-ubuntu/|ici]] une page de blog qui m'a été très utile, testé avec succès sous festy.



==== Prérequis ====

On installe LIRC et ce qu'il faut pour compiler le module de notre télécommande :
<code>sudo apt-get install lirc lirc-modules-source module-assistant</code>
Ou par le protocole **apt**
  * [[apt://lirc|lirc]]
  * [[apt://lirc-modules-source|lirc-modules-source]]
  * [[apt://module-assistant|module-assistant]]


==== Configuration à partir des sources ====

puis on reconfigure à partir des sources :

<code>sudo dpkg-reconfigure lirc-modules-source</code>

Sur l'écran qui apparaît, cliquez sur **Ok**

Dans l'ecran proposant de choisir le module lirc choisir : **atiusb** puis **Ok**

Répondre **No** sur l'écran suivant puis **Install the package maintener version** et **Ok**

<code>gksudo gedit /etc/lirc/hardware.conf</code>

Rajoutez :

<code>MODULES="lirc_atiusb"</code>


==== Finalisation ====

Puis copier les lignes suivantes dans un terminal :

<code>sudo m-a update,prepare 
sudo rm /usr/src/lirc*deb
sudo m-a clean lirc
sudo m-a a-i lirc
sudo depmod -a</code>



==== Suppression du module ati_remote ====

On empêche le chargement du module (pilote) ati_remote :
<code>gksudo gedit /etc/modprobe.d/blacklist</code>

On rajoute ceci à la fin :

<code># Télécommande ATI
blacklist ati_remote</code>





==== Configurer sa télécommande ====

<code>gksudo gedit /etc/lirc/lircd.conf</code>

LE contenu du fichier doit reprendre le fichier de configuration de votre télécommande. Voir http://lirc.sourceforge.net/remotes/atiusb/lircd.conf.atiusb

Pour lancer lirc au démarrage de Gnome :

**Système** >> **Préférences** >> **Sessions** >> **Programmes au démarrage**

et ajouter irexec

Ensuite reste le plus "facile" configurer les programmes pour utiliser notre télécommande.

<code>gedit ~/.lircrc</code>

Vous trouverez des exemples de fichiers de configuration pour Lirc sur le wiki : [[:tutoriel:lircrc|Création de fichiers lircrc]].

Pour finaliser l'installation redémarrez votre ordinateur.

Si vous avez des doutes sur la réussite de votre installation, lancez un Terminal et tapez le commande :

<code>irw</code>

Lors de l'appui sur une des touche de votre télécommande le Terminal doit vous signaler un evenement.

Bon courage !!

=====Voir aussi=====

  * [[http://blog.roozeec.fr/2007/04/18/telecommande-ati-remote-wonder-sous-ubuntu/|Tutoriel très utile pour paramétrer les touches]]

